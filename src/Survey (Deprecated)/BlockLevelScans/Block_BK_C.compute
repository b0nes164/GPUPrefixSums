/******************************************************************************
 * Block Level Warp-Sized Radix Brent Kung using shared memory.
 * 
 * Variant: Partitions divided into sub partitions equal to the square of the wave size
 *
 * Notes: **Unrolls and preprocessor macros must be manually changed for AMD**
 *
 * Author:  Thomas Smith 5/9/2023
 *
 * License: The Unlicense
 *          This is free and unencumbered software released into the public domain.
 *          For more information, please refer to the repository license or <https://unlicense.org>
 *
 ******************************************************************************/
#pragma use_dxc
#pragma kernel Init
#pragma kernel Block_BK_C
#pragma kernel Block_BK_C_Timing

#define PARTITION_SIZE  8192      
#define PARTITION_MASK  8191
#define PART_LOG        13
#define GROUP_SIZE      1024

#define SUB_PARTITION_SIZE  1024        //  <---------------------------   For Nvidia; change depending on hardware
#define SUB_PARTITION_MASK  1023
#define SUB_PART_LOG        10
#define LANE_COUNT          32  
#define LANE_MASK           31
#define LANE_LOG            5

//#define SUB_PARTITION_SIZE    4096        <----------------------------   AMD 
//#define SUB_PARTITION_MASK    4095
//#define SUB_PART_LOG          12
//#define LANE_COUNT            64 
//#define LANE_MASK             63
//#define LANE_LOG              6    

#define WAVE_INDEX          (gtid.x >> LANE_LOG)
#define SPINE_INDEX         (((gtid.x + 1) << LANE_LOG) - 1)
#define PARTITIONS          ((e_size & PARTITION_MASK) ? \
                            (e_size >> PART_LOG) + 1 : \
                            e_size >> PART_LOG)
#define PARTITION_START     (partitionIndex << PART_LOG)
#define SUB_PARTITIONS      (PARTITION_SIZE >> SUB_PART_LOG)
#define EXACT_SIZE          (e_size - (partitionIndex << PART_LOG))

extern int e_size;
extern int e_repeats;

RWBuffer<uint> b_prefixSum;
groupshared uint g_sharedMem[PARTITION_SIZE];

[numthreads(GROUP_SIZE, 1, 1)]
void Init(int3 id : SV_DispatchThreadID)
{
    for (int i = id.x; i < e_size; i += (GROUP_SIZE << 8))
        b_prefixSum[i] = 1;
}

[numthreads(GROUP_SIZE, 1, 1)]
void Block_BK_C(int3 gtid : SV_GroupThreadID)
{
    uint aggregate = 0;
    for (int partitionIndex = 0; partitionIndex < PARTITIONS - 1; ++partitionIndex)
    {
        [unroll(8)]
        for (int i = gtid.x; i < PARTITION_SIZE; i += GROUP_SIZE)
        {
            g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
            g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]);
        }
        GroupMemoryBarrierWithGroupSync();
        
        if (gtid.x < (PARTITION_SIZE >> LANE_LOG))
            g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
        GroupMemoryBarrierWithGroupSync();
        
        for (int j = 0; j < SUB_PARTITIONS; ++j)
        {
            const int t = gtid.x + (j << SUB_PART_LOG);
            b_prefixSum[t + PARTITION_START] = g_sharedMem[t] + aggregate +
                ((t + 1 & LANE_MASK) && WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[t - 1]) : 0);

            aggregate += WaveReadLaneFirst(g_sharedMem[(j + 1 << SUB_PART_LOG) - 1]);
        }
    }
    
    for (int i = gtid.x; i < EXACT_SIZE; i += GROUP_SIZE)
    {
        g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
        g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]);
    }
    GroupMemoryBarrierWithGroupSync();
        
    if (gtid.x < (EXACT_SIZE >> LANE_LOG))
        g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
    GroupMemoryBarrierWithGroupSync();

    for (int j = 0; j < SUB_PARTITIONS; ++j)
    {
        const int t = gtid.x + (j << SUB_PART_LOG);
        if (t < EXACT_SIZE)
        {
            b_prefixSum[t + PARTITION_START] = g_sharedMem[t] + aggregate +
                ((t + 1 & LANE_MASK) && WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[t - 1]) : 0);
            
            aggregate += WaveReadLaneFirst(g_sharedMem[(j + 1 << SUB_PART_LOG) - 1]);
        }
    }
}

/******************************************************************************
 * This is timing version of the scan. It is as similar as possible to the above
 * algorithm except that it can perform multiple loops. HOWEVER, IT IS NOT IDENTICAL,
 * and should only be interpreted as an approximation of the original algorithm. 
 ******************************************************************************/
[numthreads(GROUP_SIZE, 1, 1)]
void Block_BK_C_Timing(int3 gtid : SV_GroupThreadID)
{
    for (int g = 0; g < e_repeats; ++g)
    {
        uint aggregate = 0;
        for (int partitionIndex = 0; partitionIndex < PARTITIONS - 1; ++partitionIndex)
        {
            [unroll(8)]
            for (int i = gtid.x; i < PARTITION_SIZE; i += GROUP_SIZE)
            {
                g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
                g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]);
            }
            GroupMemoryBarrierWithGroupSync();
        
            if (gtid.x < (PARTITION_SIZE >> LANE_LOG))
                g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
            GroupMemoryBarrierWithGroupSync();
        
            for (int j = 0; j < SUB_PARTITIONS; ++j)
            {
                const int t = gtid.x + (j << SUB_PART_LOG);
                b_prefixSum[t + PARTITION_START] = g_sharedMem[t] + aggregate +
                    ((t + 1 & LANE_MASK) && WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[t - 1]) : 0);

                aggregate += WaveReadLaneFirst(g_sharedMem[(j + 1 << SUB_PART_LOG) - 1]);
            }
        }
    
        for (int i = gtid.x; i < EXACT_SIZE; i += GROUP_SIZE)
        {
            g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
            g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]);
        }
        GroupMemoryBarrierWithGroupSync();
        
        if (gtid.x < (EXACT_SIZE >> LANE_LOG))
            g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
        GroupMemoryBarrierWithGroupSync();

        for (int j = 0; j < SUB_PARTITIONS; ++j)
        {
            const int t = gtid.x + (j << SUB_PART_LOG);
            if (t < EXACT_SIZE)
            {
                b_prefixSum[t + PARTITION_START] = g_sharedMem[t] + aggregate +
                    ((t + 1 & LANE_MASK) && WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[t - 1]) : 0);
                
                aggregate += WaveReadLaneFirst(g_sharedMem[(j + 1 << SUB_PART_LOG) - 1]);
            }
        }
    }
}