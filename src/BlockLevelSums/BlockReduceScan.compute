/******************************************************************************************************************
 * Block Level Reduce Scan using Brent-Kung
 * 
 * Notes:   Reduces the partition then passes the aggregates into a downsweep
 *          **Unrolls and preprocessor macros must be manually changed for AMD**          
 *
 * Author:  Thomas Smith 5/9/2023
 *
 * License: The Unlicense
 *          This is free and unencumbered software released into the public domain.
 *          For more information, please refer to the repository license or <https://unlicense.org>
 *
 ******************************************************************************/
#pragma use_dxc
#pragma kernel Init
#pragma kernel BlockReduceScan
#pragma kernel BlockReduceScanTiming

#define SUB_PARTITION_SIZE  8192
#define GROUP_SIZE          1024

// For Nvidia; change depending on hardware
#define LANE_COUNT  32  
#define LANE_MASK   31
#define LANE_LOG    5

#define WAVE_PARTITION_SIZE     256
#define WAVE_PARTITION_MASK     255
#define WAVES_PER_GROUP         32
#define WAVES_PER_GROUP_MASK    31
#define WAVE_PART_LOG           8
#define WAVES_PER_GROUP_LOG     5

//AMD
/*
 * #define LANE_COUNT           64  
 * #define LANE_MASK            63
 * #define LANE_LOG             6 
 *
 * #define WAVE_PARTITION_SIZE  512
 * #define WAVE_PARTITION_MASK  511
 * #define WAVES_PER_GROUP      16
 * #define WAVES_PER_GROUP_MASK 15
 * #define WAVE_PART_LOG        9
 * #define WAVES_PER_GROUP_LOG  4
 */

#define LANE            (gtid.x & LANE_MASK)
#define WAVE_INDEX      (gtid.x >> LANE_LOG)
#define SPINE_INDEX     (((i + 1) << offset) + WAVE_PART_START - 1)
#define PARTITION_SIZE  ((e_size & WAVES_PER_GROUP_MASK) ? \
                        (e_size >> WAVES_PER_GROUP_LOG) + 1 : \
                        e_size >> WAVES_PER_GROUP_LOG)
#define PARTITION_START (WAVE_INDEX * PARTITION_SIZE)
#define WAVE_PART_START (WAVE_INDEX << WAVE_PART_LOG)
#define EXACT_SIZE      ((WAVE_INDEX + 1 & LANE_MASK) ? PARTITION_SIZE : e_size - LANE_MASK * PARTITION_SIZE)
#define SUB_PARTITIONS  ((EXACT_SIZE & WAVE_PARTITION_MASK) ? \
                        (EXACT_SIZE >> WAVE_PART_LOG) + 1 : \
                        EXACT_SIZE >> WAVE_PART_LOG)
#define SUB_PART_START  (PARTITION_START + (subPartionIndex << WAVE_PART_LOG))
#define NEXT_POWER      (j << LANE_LOG)

extern int e_size;
extern int e_repeats;

RWBuffer<uint> b_prefixSum;
globallycoherent RWBuffer<uint> b_state;
groupshared uint g_sharedMem[SUB_PARTITION_SIZE];

[numthreads(GROUP_SIZE, 1, 1)]
void Init(int3 id : SV_DispatchThreadID)
{
    for (int i = id.x; i < e_size; i += (GROUP_SIZE << 8))
        b_prefixSum[i] = 1;
}

[numthreads(GROUP_SIZE, 1, 1)]
void BlockReduceScan(int3 gtid : SV_GroupThreadID)
{
    //Reduce
    uint aggregate = 0;
    for (int i = LANE + PARTITION_START; i <  PARTITION_START + EXACT_SIZE; i += LANE_COUNT)
        aggregate += WaveActiveSum(b_prefixSum[i]);
    GroupMemoryBarrierWithGroupSync();
    
    if (LANE == 0)
        g_sharedMem[WAVE_INDEX] = aggregate;
    GroupMemoryBarrierWithGroupSync();
    
    if(gtid.x < WAVES_PER_GROUP)
        g_sharedMem[gtid.x] = WavePrefixSum(g_sharedMem[gtid.x]);
    GroupMemoryBarrierWithGroupSync();
    
    aggregate = WaveReadLaneFirst(g_sharedMem[WAVE_INDEX]);
    GroupMemoryBarrierWithGroupSync();
    
    //Scan
    for(int subPartionIndex = 0; subPartionIndex < SUB_PARTITIONS - 1; ++subPartionIndex)
    {   
        [unroll(8)]
        for (int i = LANE; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
        {
            g_sharedMem[i + WAVE_PART_START] = b_prefixSum[i + SUB_PART_START];
            g_sharedMem[i + WAVE_PART_START] += WavePrefixSum(g_sharedMem[i + WAVE_PART_START]);
        }
        
        b_prefixSum[SUB_PART_START + LANE] = g_sharedMem[LANE + WAVE_PART_START] + aggregate;
        
        int offset = LANE_LOG;
        for (int j = 1 << LANE_LOG; j < WAVE_PARTITION_SIZE; j <<= LANE_LOG)
        {
            for (int i = LANE; i < (WAVE_PARTITION_SIZE >> offset); i += LANE_COUNT)
                g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
            
            for (int i = LANE + j; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
            {
                if ((i & NEXT_POWER - 1) >= j)
                {
                    if (i < NEXT_POWER)
                    {
                        b_prefixSum[SUB_PART_START + i] = g_sharedMem[i + WAVE_PART_START] + aggregate +
                                ((i + 1 & j - 1) ? WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]) : 0);
                    }
                    else
                    {
                        if ((i + 1 & j - 1) != 0)
                            g_sharedMem[i + WAVE_PART_START] += WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]);
                    }
                }
            }
            offset += LANE_LOG;
        }
        
        aggregate += WaveReadLaneFirst(g_sharedMem[WAVE_PARTITION_SIZE + WAVE_PART_START - 1]);
    }
    
    //Offsize pass
    const int wavePartitionSize = PARTITION_SIZE - (subPartionIndex << WAVE_PART_LOG);
    for (int i = LANE; i < wavePartitionSize; i += LANE_COUNT)
    {
        g_sharedMem[i + WAVE_PART_START] = b_prefixSum[i + SUB_PART_START];
        g_sharedMem[i + WAVE_PART_START] += WavePrefixSum(g_sharedMem[i + WAVE_PART_START]);
    }
    
    if (LANE < wavePartitionSize)
        b_prefixSum[SUB_PART_START + LANE] = g_sharedMem[LANE + WAVE_PART_START] + aggregate;
        
    int offset = LANE_LOG;
    for (int j = 1 << LANE_LOG; j < wavePartitionSize; j <<= LANE_LOG)
    {
        for (int i = LANE; i < (wavePartitionSize >> offset); i += LANE_COUNT)
            g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
            
        for (int i = LANE + j; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
        {
            if ((i & NEXT_POWER - 1) >= j)
            {
                if (i < NEXT_POWER)
                {
                    b_prefixSum[SUB_PART_START + i] = g_sharedMem[i + WAVE_PART_START] + aggregate +
                                ((i + 1 & j - 1) ? WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]) : 0);
                }
                else
                {
                    if ((i + 1 & j - 1) != 0)
                        g_sharedMem[i + WAVE_PART_START] += WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]);
                }
            }
        }
        offset += LANE_LOG;
    }
}

/******************************************************************************
 * This is timing version of the scan. It is as similar as possible to the above
 * algorithm except that it can perform multiple loops. HOWEVER, IT IS NOT IDENTICAL,
 * and should only be interpreted as an approximation of the original algorithm. 
 ******************************************************************************/
[numthreads(GROUP_SIZE, 1, 1)]
void BlockReduceScanTiming(int3 gtid : SV_GroupThreadID)
{
    for (int g = 0; g < e_repeats; ++g)
    {
        uint aggregate = 0;
        for (int i = LANE + PARTITION_START; i < PARTITION_START + EXACT_SIZE; i += LANE_COUNT)
            aggregate += WaveActiveSum(b_prefixSum[i]);
        GroupMemoryBarrierWithGroupSync();
    
        if (LANE == 0)
            g_sharedMem[WAVE_INDEX] = aggregate;
        GroupMemoryBarrierWithGroupSync();
    
        if (gtid.x < WAVES_PER_GROUP)
            g_sharedMem[gtid.x] = WavePrefixSum(g_sharedMem[gtid.x]);
        GroupMemoryBarrierWithGroupSync();
    
        aggregate = WaveReadLaneFirst(g_sharedMem[WAVE_INDEX]);
        GroupMemoryBarrierWithGroupSync();
    
        for (int subPartionIndex = 0; subPartionIndex < SUB_PARTITIONS - 1; ++subPartionIndex)
        {
            [unroll(8)]
            for (int i = LANE; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
            {
                g_sharedMem[i + WAVE_PART_START] = b_prefixSum[i + SUB_PART_START];
                g_sharedMem[i + WAVE_PART_START] += WavePrefixSum(g_sharedMem[i + WAVE_PART_START]);
            }
        
            b_prefixSum[SUB_PART_START + LANE] = g_sharedMem[LANE + WAVE_PART_START] + aggregate;
        
            int offset = LANE_LOG;
            for (int j = 1 << LANE_LOG; j < WAVE_PARTITION_SIZE; j <<= LANE_LOG)
            {
                for (int i = LANE; i < (WAVE_PARTITION_SIZE >> offset); i += LANE_COUNT)
                    g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
            
                for (int i = LANE + j; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
                {
                    if ((i & NEXT_POWER - 1) >= j)
                    {
                        if (i < NEXT_POWER)
                        {
                            b_prefixSum[SUB_PART_START + i] = g_sharedMem[i + WAVE_PART_START] + aggregate +
                                ((i + 1 & j - 1) ? WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]) : 0);
                        }
                        else
                        {
                            if ((i + 1 & j - 1) != 0)
                                g_sharedMem[i + WAVE_PART_START] += WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]);
                        }
                    }
                }
                offset += LANE_LOG;
            }
        
            aggregate += WaveReadLaneFirst(g_sharedMem[WAVE_PARTITION_SIZE + WAVE_PART_START - 1]);
        }
    
        const int wavePartitionSize = PARTITION_SIZE - (subPartionIndex << WAVE_PART_LOG);
        for (int i = LANE; i < wavePartitionSize; i += LANE_COUNT)
        {
            g_sharedMem[i + WAVE_PART_START] = b_prefixSum[i + SUB_PART_START];
            g_sharedMem[i + WAVE_PART_START] += WavePrefixSum(g_sharedMem[i + WAVE_PART_START]);
        }
    
        if (LANE < wavePartitionSize)
            b_prefixSum[SUB_PART_START + LANE] = g_sharedMem[LANE + WAVE_PART_START] + aggregate;
        
        int offset = LANE_LOG;
        for (int j = 1 << LANE_LOG; j < wavePartitionSize; j <<= LANE_LOG)
        {
            for (int i = LANE; i < (wavePartitionSize >> offset); i += LANE_COUNT)
                g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]);
            
            for (int i = LANE + j; i < WAVE_PARTITION_SIZE; i += LANE_COUNT)
            {
                if ((i & NEXT_POWER - 1) >= j)
                {
                    if (i < NEXT_POWER)
                    {
                        b_prefixSum[SUB_PART_START + i] = g_sharedMem[i + WAVE_PART_START] + aggregate +
                                ((i + 1 & j - 1) ? WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]) : 0);
                    }
                    else
                    {
                        if ((i + 1 & j - 1) != 0)
                            g_sharedMem[i + WAVE_PART_START] += WaveReadLaneFirst(g_sharedMem[i + WAVE_PART_START - 1]);
                    }
                }
            }
            offset += LANE_LOG;
        }
    }
}