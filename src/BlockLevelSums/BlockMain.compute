/*****************************************************************************
 * Block Level Warp-Scan Raking Reduce then Scan
 * 
 * Variant: Partition tile equal to the maximum size of shared memory.
 *          The partition is equally subdivided amongst the warps. 
 *          Each warp calculates an aggregate using serial Kogge-Stone warp-scans.
 *          The block-wide aggregate is computed using a single Kogge-Stone warp-scan. 
 *
 * Notes: **Unrolls and preprocessor macros must be manually changed for AMD**
 * 
 * Author:  Thomas Smith 5/9/2023
 * 
 * License: The Unlicense
 *          This is free and unencumbered software released into the public domain.
 *          For more information, please refer to the repository license or <https://unlicense.org>
 *
 ******************************************************************************/
#pragma use_dxc
#pragma kernel Init
#pragma kernel BlockMain
#pragma kernel BlockMainTiming

#define PARTITION_SIZE      8192
#define PARTITION_MASK      8191
#define PART_LOG            13
#define GROUP_SIZE          1024

#define LANE_COUNT          32  // <---------------------------   For Nvidia; change depending on hardware
#define LANE_MASK           31
#define LANE_LOG            5
#define WAVES_PER_GROUP     32
#define WAVE_PARTITION_SIZE 256
#define WAVE_PART_LOG       8

//#define LANE_COUNT            64 <-------------------------   AMD 
//#define LANE_MASK             63
//#define LANE_LOG              6    
//#define WAVES_PER_GROUP       16
//#define WAVE_PARTITION_SIZE   512
//#define WAVE_PART_LOG         9

#define LANE                (gtid.x & LANE_MASK)
#define WAVE_INDEX          (gtid.x >> LANE_LOG)
#define SPINE_INDEX         (((gtid.x + 1) << WAVE_PART_LOG) - 1)
#define PARTITIONS          ((e_size & PARTITION_MASK) ? \
                            (e_size >> PART_LOG) + 1 : \
                            e_size >> PART_LOG)
#define PARTITION_START     (partitionIndex << PART_LOG)
#define EXACT_SIZE          (e_size - PARTITION_START)
#define WAVE_PART_START     (WAVE_INDEX << WAVE_PART_LOG)
#define WAVE_PART_END       (WAVE_INDEX + 1 << WAVE_PART_LOG)

extern int e_size;
extern int e_repeats;

RWBuffer<uint> b_prefixSum;
groupshared uint g_sharedMem[PARTITION_SIZE];

[numthreads(GROUP_SIZE, 1, 1)]
void Init(int3 id : SV_DispatchThreadID)
{
    for (int i = id.x; i < e_size; i += (GROUP_SIZE << 8))
        b_prefixSum[i] = 1;
}

[numthreads(GROUP_SIZE, 1, 1)]
void BlockMain(int3 gtid : SV_GroupThreadID)
{
    uint aggregate = 0;
    for (int partitionIndex = 0; partitionIndex < PARTITIONS - 1; ++partitionIndex)
    {
        g_sharedMem[LANE + WAVE_PART_START] = b_prefixSum[LANE + WAVE_PART_START + PARTITION_START];
        g_sharedMem[LANE + WAVE_PART_START] += WavePrefixSum(g_sharedMem[LANE + WAVE_PART_START]);
        
        [unroll(7)]
        for (int i = LANE + WAVE_PART_START + LANE_COUNT; i < WAVE_PART_END; i += LANE_COUNT)
        {
            g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
            g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]) + WaveReadLaneFirst(g_sharedMem[i - 1]);
        }
        GroupMemoryBarrierWithGroupSync();
        
        if (gtid.x < WAVES_PER_GROUP)
            g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]) + aggregate;
        GroupMemoryBarrierWithGroupSync();
        
        const uint prev = WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[WAVE_PART_START - 1]) : aggregate;
        [unroll(8)]
        for (int i = LANE + WAVE_PART_START; i < WAVE_PART_END; i += LANE_COUNT)
            b_prefixSum[i + PARTITION_START] = g_sharedMem[i] + (i < WAVE_PART_END - 1 ? prev : 0);
        
        aggregate = WaveReadLaneFirst(g_sharedMem[PARTITION_MASK]);
        GroupMemoryBarrierWithGroupSync();
    }
    
    int wavePartEnd = WAVE_PART_END;
    if (wavePartEnd > EXACT_SIZE)
        wavePartEnd = (EXACT_SIZE - 1 >> WAVE_PART_LOG) == WAVE_INDEX ? EXACT_SIZE : 0;
    
    if (LANE < (wavePartEnd - WAVE_PART_START))
    {
        g_sharedMem[LANE + WAVE_PART_START] = b_prefixSum[LANE + WAVE_PART_START + PARTITION_START];
        g_sharedMem[LANE + WAVE_PART_START] += WavePrefixSum(g_sharedMem[LANE + WAVE_PART_START]);
    }
    for (int i = LANE + WAVE_PART_START + LANE_COUNT; i < wavePartEnd; i += LANE_COUNT)
    {
        g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
        g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]) + WaveReadLaneFirst(g_sharedMem[i - 1]);
    }
    GroupMemoryBarrierWithGroupSync();
        
    //groupwide partition aggregate
    if (gtid.x < WAVES_PER_GROUP)
    {
        int t = SPINE_INDEX;
        if (t > EXACT_SIZE - 1)
            t = (EXACT_SIZE - 1 >> WAVE_PART_LOG) == gtid.x ? EXACT_SIZE - 1 : PARTITION_SIZE - gtid.x;
        g_sharedMem[t] += WavePrefixSum(g_sharedMem[t]) + aggregate;
    }
    GroupMemoryBarrierWithGroupSync();
        
    const uint prev = WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[WAVE_PART_START - 1]) : aggregate;
    for (int i = LANE + WAVE_PART_START; i < wavePartEnd; i += LANE_COUNT)
        b_prefixSum[i + PARTITION_START] = g_sharedMem[i] + (i < wavePartEnd - 1 ? prev : 0);
}

/******************************************************************************
 * This is timing version of the scan. It is as similar as possible to the above
 * algorithm except that it can perform multiple loops. HOWEVER, IT IS NOT IDENTICAL,
 * and should only be interpreted as an approximation of the original algorithm. 
 ******************************************************************************/
[numthreads(GROUP_SIZE, 1, 1)]
void BlockMainTiming(int3 gtid : SV_GroupThreadID)
{
    for(int g = 0; g < e_repeats; ++g)
    {
        uint aggregate = 0;
        for (int partitionIndex = 0; partitionIndex < PARTITIONS - 1; ++partitionIndex)
        {
            g_sharedMem[LANE + WAVE_PART_START] = b_prefixSum[LANE + WAVE_PART_START + PARTITION_START];
            g_sharedMem[LANE + WAVE_PART_START] += WavePrefixSum(g_sharedMem[LANE + WAVE_PART_START]);
        
            [unroll(7)]
            for (int i = LANE + WAVE_PART_START + LANE_COUNT; i < WAVE_PART_END; i += LANE_COUNT)
            {
                g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
                g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]) + WaveReadLaneFirst(g_sharedMem[i - 1]);
            }
            GroupMemoryBarrierWithGroupSync();
        
            if (gtid.x < WAVES_PER_GROUP)
                g_sharedMem[SPINE_INDEX] += WavePrefixSum(g_sharedMem[SPINE_INDEX]) + aggregate;
            GroupMemoryBarrierWithGroupSync();
        
            const uint prev = WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[WAVE_PART_START - 1]) : aggregate;
            [unroll(8)]
            for (int i = LANE + WAVE_PART_START; i < WAVE_PART_END; i += LANE_COUNT)
                b_prefixSum[i + PARTITION_START] = g_sharedMem[i] + (i < WAVE_PART_END - 1 ? prev : 0);
            
            aggregate = WaveReadLaneFirst(g_sharedMem[PARTITION_SIZE - 1]);
            GroupMemoryBarrierWithGroupSync();
        }
        
        int wavePartEnd = WAVE_PART_END;
        if (wavePartEnd > EXACT_SIZE)
            wavePartEnd = (EXACT_SIZE - 1 >> WAVE_PART_LOG) == WAVE_INDEX ? EXACT_SIZE : 0;
        
        if (LANE < (wavePartEnd - WAVE_PART_START))
        {
            g_sharedMem[LANE + WAVE_PART_START] = b_prefixSum[LANE + WAVE_PART_START + PARTITION_START];
            g_sharedMem[LANE + WAVE_PART_START] += WavePrefixSum(g_sharedMem[LANE + WAVE_PART_START]);
        }
        for (int i = LANE + WAVE_PART_START + LANE_COUNT; i < wavePartEnd; i += LANE_COUNT)
        {
            g_sharedMem[i] = b_prefixSum[i + PARTITION_START];
            g_sharedMem[i] += WavePrefixSum(g_sharedMem[i]) + WaveReadLaneFirst(g_sharedMem[i - 1]);
        }
        GroupMemoryBarrierWithGroupSync();
        
        if (gtid.x < WAVES_PER_GROUP)
        {
            int t = SPINE_INDEX;
            if (t > EXACT_SIZE - 1)
                t = (EXACT_SIZE - 1 >> WAVE_PART_LOG) == gtid.x ? EXACT_SIZE - 1 : PARTITION_SIZE - gtid.x;
            g_sharedMem[t] += WavePrefixSum(g_sharedMem[t]) + aggregate;
        }
        GroupMemoryBarrierWithGroupSync();
        
        const uint prev = WAVE_INDEX ? WaveReadLaneFirst(g_sharedMem[WAVE_PART_START - 1]) : aggregate;
        for (int i = LANE + WAVE_PART_START; i < wavePartEnd; i += LANE_COUNT)
            b_prefixSum[i + PARTITION_START] = g_sharedMem[i] + (i < wavePartEnd - 1 ? prev : 0);
    }
}
